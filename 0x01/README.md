# 0x01 기초 코드 작성 요령 I

## 시간 복잡도 (Time Complexity)

> 입력과 크기의 문제를 해결하는데 걸리는 시간의 상관관계

- 컴퓨터는 1초에 대략 3-5억 개 정도의 연산 처리 가능

### 예제

```cpp
int func1(inmt arr[], int n) {
  int cnt = 0;
  for (int i = 0; i < n; i++) {
    if (arr[i] % 5 == 0) cnt++;
  }
  return cnt;
}
```

- **시간 복잡도** : 1 + 1 + n ｘ (2 + 2 + 1) + 1 = **5n + 3**
- 보통 **_N에 비례한다._** 라고 함 (→ 빅오표기법)

### 빅오표기법 (Big-O Notation)

> **주어진 식을 값이 가장 큰 대표항만 남겨서 나타내는 방법**  
> 코테에선 주로 1-5초

- **O(N)** : **5N** + 3, **2N** + 10lgN, **10N**
- **O(N²)** : **N²** + 2N + 4, **6N²** + 20N + 10lgN
- **O(NlgN)** : **NlgN** + 30N + 10, **5NlgN** + 6
- **O(1)** : 5, 16, 36

> [!NOTE]
> N이 커짐에 따라 시간 복잡도가 올라감  
> O(1) < O(lgN) < O(N) < O(NlgN) < O(N²) < O(2<sup>N</sup>) < O(N!)

## 공간 복잡도

> **입력의 크기와 문제를 해결하는데 필요한 공간의 상관관계**  
> 크게 신경 안써도 됨

### 예제

- **O(N²)** : N짜리 2차원 배열
- **O(1)** : 배열 필요 X

> [!NOTE]
> 메모리 제한이 512MB일 때 대략 1.2억 개의 int 변수 선언 가능

## 정수 자료형

### char

- **크기** : 1 byte = 8 bit
- **범위** : -2⁷ ~ (2⁷-1)
- **최솟값** : 10000000 = -128
- **최댓값** : 01111111 = 127
- 독특하게 제일 왼쪽이 -2⁷ (→ 2의 보수법 때문)

### unsigned char

- **크기** : 1 byte = 8 bit
- **범위** : 0 ~ (2⁸-1)
- **최솟값** : 00000000 = 0
- **최댓값** : 11111111 = 255

### short

- **크기** : 2 byte
- **최댓값** : 2¹⁵-1
- 잘 안쓰임

### int

- **크기** : 4 byte
- **최댓값** : 2³¹-1

### long long

- **크기** : 8 byte
- **최댓값** : 2⁶³-1
- int 자료형이 표현할 수 있는 범위 넘어서면 반드시 long long 자료형을 사용해야 함
  - 예) 80번째 피보나치 수 구하기

### Integer Overflow

- 01111111 + 00000001 = 10000000 (127 + 1 = -128)
- 컴퓨터는 명령받은 대로 이진수 계산을 하였지만 그 결과가 옳지 못함

## 실수 자료형

### float

- **크기** : 4 byte

### double

- **크기** : 8 byte

> [!NOTE]
> 나중에 정리
