# 0x03 배열

## 배열

> **메모리 상에 원소를 연속하게 배치한 자료구조**

> [!NOTE]  
> 원래 배열은 선언한 뒤 길이를 변경할 수 없으나 자료구조에선 가능하다고 가정

### 성질

1. O(1)에 k번째 원소를 확인/변경 가능
2. 추가적으로 소모되는 메모리의 양(=overhead)가 거의 없음
3. Cache hit rate(캐시 적중률)가 높음
   > **캐시 적중률** : 명령이나 자료를 찾기 위해 캐시 메모리에 접근함
   > 원하는 정보가 캐시 메모리에 있을 때는 적중(hit), 아닐 때는 실패  
   > (적정률) = (적중횟수) / (총 접근횟수)  
   > 즉, 컴퓨터 성능 나타내는 척도 (0.95~0.99 사이 일 때 우수)
4. 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림

### 기능과 구현

#### 임의의 위치에 있는 원소를 확인/변경, O(1)

#### 원소를 끝에 추가, O(1)

- 끝자리에 값 쓰고 길이 1 증가

#### 마지막 원소 제거, O(1)

- 길이 1 감소

#### 임의의 위치에 원소를 추가, O(N)

- 추가할 위치 뒤의 원소를 한 칸씩 뒤로 밀고 원소 추가
- 임의의 위치가 앞에 가까울수록 시간 ↑
- 임의의 위치가 끝에 가까울수록 시간 ↓
- 평균적으로 N/2개를 밀어야함

#### 임의의 위치에 있는 원소를 제거, O(N)

- 임의의 위치에 있는 원소를 제거하고 그 뒤 원소를 한 칸씩 앞으로 땡겨야함

## 전체를 특정 값으로 초기화 시키는 방법

### cstring 헤더에 있는 memset 함수

- 실수할 여지 굉장히 많음
  - 0이나 -1이 아닌 다른 값 넣으면 오동작
  - 2차원 이상의 배열을 함수의 인자로 넘겨 memset하면 잘못 들어감
- **비추!!!!**

### for문

- 코드가 투박하나 실수할 여지 X

### algorithm 헤더의 fill 함수

- 실수할 여지 X, 짧은 코드
- **가장 추천!!!**

## STL vector

- 배열과 거의 동일한 기능을 수행하는 자료구조
- 배열과 마찬가지로 O(1)에 인덱스를 가지고 각 원소로 접근 가능
   - 원소가 메모리에 연속하게 저장되어있기 때문
- 배열과 달리 크기를 자유자재로 늘이거나 줄일 수 있음
- vector에서 `=`을 사용하면 deep copy 발생

---

#### 연습문제

- [x] 10808 : [알파벳 개수](https://www.acmicpc.net/problem/10808)

#### 기본문제

- [x] 2577 : [숫자의 개수](https://www.acmicpc.net/problem/2577)
- [x] 1475 : [방 번호](https://www.acmicpc.net/problem/1475)
- [x] 3273 : [두 수의 합](https://www.acmicpc.net/problem/3273)
- [x] 10807 : [개수 세기](https://www.acmicpc.net/problem/10807)
- [x] 13300 : [방 배정](https://www.acmicpc.net/problem/13300)
- [x] 11328 : [Strfry](https://www.acmicpc.net/problem/11328)
- [x] 1919 : [애너그램 만들기](https://www.acmicpc.net/problem/1919)
